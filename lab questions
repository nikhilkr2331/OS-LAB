10.  IMPLEMENT INTER-PROCESS communication using pipes, you have to the pass the message from child to parent.

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main(){
    int pipefd[2];
    char buffer[25];
    pid_t pid;
    if(pipe(pipefd)==-1){
    printf("pipe failed\n");
    return 1;
    }
    pid = fork();
    if(pid < 0){
    printf("fork failed\n");
    return 1;
    }
    if(pid > 0){
    close(pipefd[0]);
    printf("parent process writing to pipe...\n");
    write(pipefd[1],"Hello, child process!",22);
    close(pipefd[1]);
    }
    else{
    close(pipefd[1]);
    printf("child process reading from pipe...\n");
    read(pipefd[0],buffer,25);
    printf("child process received : %s\n", buffer);
    close(pipefd[0]);
    }
    return 0;
    }



9. Implement inter-process communication using shared memory.


shared_sender.c


#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/shm.h>
#include<string.h>
int main(){
void *shared_memory;
char buff[100];
int shmid;
shmid=shmget((key_t)1122, 1024, 0666|IPC_CREAT);
printf("Key of shared memory is %d\n",shmid);
shared_memory=shmat(shmid,NULL,0);
printf("Process attached at %p\n",shared_memory);
printf("Enter some data to write to shared memory\n");
read(0,buff,100);
strcpy(shared_memory,buff);
printf("You wrote : %s\n",(char *)shared_memory);
}




shared_receiver.c


#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/shm.h>
#include<string.h>
int main(){
void *shared_memory;
char buff[100];
int shmid;
shmid = shmget((key_t)1122, 1024, 0666);
printf("Key of shared memory is %d\n", shmid);
shared_memory=shmat(shmid,NULL,0);
printf("Process attached at %p\n",shared_memory);
printf("Data read from shared memory is : %s\n",(char *)shared_memory);
}




8.Write a program on process synchronization where you have a provided the solution to race condition using mutex_lock


#include<pthread.h>
#include<unistd.h>
void *fun1();
void *fun2();
int shared=1;
pthread_mutex_t l;
int main(){
pthread_mutex_init(&l, NULL);
pthread_t thread1, thread2;
pthread_create(&thread1, NULL, fun1, NULL);
pthread_create(&thread2, NULL, fun2, NULL);
pthread_join(thread1, NULL);
pthread_join(thread2, NULL);
printf("Final value of shared is %d\n", shared);
}

void *fun1(){
int x;
printf("Thread1 trying to acquire lock\n");
pthread_mutex_lock(&l);

printf("Thread1 acquired lock\n");
x=shared;
printf("Thread1 reads the value of shared variable as %d\n",x);
x++;
printf("Local updation by Thread1: %d\n",x);
sleep(1);
shared=x;
printf("Value of shared variable updated by Thread1 is: %d\n", shared);
pthread_mutex_unlock(&l);
printf("Thread1 released the lock\n");
}

void *fun2(){
int y;
printf("Thread2 trying to acquire lock\n");
pthread_mutex_lock(&l);
printf("Thread2 acquired lock\n");
y=shared;
printf("Thread2 reads the value as %d\n", y);
y--;
printf("Local updation by Thread2: %d\n",y);
sleep(1);
shared=y;
printf("Value of shared variable updated by Thread2 is: %d\n",shared);
pthread_mutex_unlock(&l);
printf("Thread2 released the lock\n");
}




7. write a program on process synchronization, where you have to provide to solution  to race condition using semaphores.


#include<pthread.h>
#include<stdio.h>
#include<semaphore.h>
#include<unistd.h>

void *fun1();
void *fun2();
int shared=1;
sem_t s;
int main(){
sem_init(&s,0,1);

pthread_t thread1, thread2;
pthread_create(&thread1, NULL, fun1, NULL);
pthread_create(&thread2, NULL, fun2, NULL);
pthread_join(thread1, NULL);
pthread_join(thread2, NULL);
printf("Final value of shared is %d\n",shared);
}

void *fun1(){
int x;
sem_wait(&s);
x=shared;
printf("Thread reads the value as %d\n",x);
x++;
printf("Local updation by Thread1: %d\n",x);
sleep(1);
shared=x;
printf("Value of shared variable updated by Thread1 is: %d\n", shared);
sem_post(&s);
}


void *fun2()
{
int y;
sem_wait(&s);
y=shared;
printf("Thread2 reads the value as %d\n",y);
y--;
printf("Local updation by Thread2: %d\n", y);
sleep(1);
shared=y;
printf("Value of shared variable updated by Thread2 is: %d\n",shared);
sem_post(&s);
}



6.  write a program using pthread to find the length of string, where strings are passed to thread function.



#include <stdio.h>
#include <pthread.h>
#include <string.h>

#define MAX_LENGTH 100

struct ThreadData {
    char *str;
    int start;
    int end;
    int length;
};

void *calculate_length(void *arg) {
    struct ThreadData *data = (struct ThreadData *)arg;
    for (int i = data->start; i < data->end && data->str[i] != '\0'; i++) {
        data->length++;
    }
    pthread_exit(NULL);
}


int main() {
    pthread_t tid1, tid2;
    char str[MAX_LENGTH];
    printf("Enter a string: ");
    fgets(str, MAX_LENGTH, stdin);
    str[strcspn(str, "\n")] = '\0';

    int len = strlen(str);
    struct ThreadData data1 = {str, 0, len / 2, 0};
    struct ThreadData data2 = {str, len / 2, len, 0};

    pthread_create(&tid1, NULL, calculate_length, (void *)&data1);
    pthread_create(&tid2, NULL, calculate_length, (void *)&data2);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    int total_length = data1.length + data2.length;
    printf("Total length of string: %d\n", total_length);

    return 0;
}


5. write a program that performs statistical operations of calculating the sum of numbers maximum and minimum
for a set of numbers. create three threads where each performs their respective operations.


#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>

#define NUM_THREADS 3

int array_size;
int numbers[100];

int sum = 0;
int max = INT_MIN;
int min = INT_MAX;

struct ThreadData {
  int start;
  int end;
};

void *calculate_sum(void *arg) {
  struct ThreadData *data = (struct ThreadData *)arg;
  for (int i = data->start; i < data->end; i++) {
    sum += numbers[i];
  }
  pthread_exit(NULL);
}

void *calculate_max(void *arg) {
  struct ThreadData *data = (struct ThreadData *)arg;
  for (int i = data->start; i < data->end; i++) {
    if (numbers[i] > max) {
      max = numbers[i];
    }
  }
  pthread_exit(NULL);
}

void *calculate_min(void *arg) {
  struct ThreadData *data = (struct ThreadData *)arg;
  for (int i = data->start; i < data->end; i++) {
    if (numbers[i] < min) {
      min = numbers[i];
    }
  }
  pthread_exit(NULL);
}

int main() {
  pthread_t threads[NUM_THREADS];
  struct ThreadData data[NUM_THREADS];

  // Get user input for array size
  printf("Enter the number of elements: ");
  scanf("%d", &array_size);

  if (array_size <= 0 || array_size > 100) {
    printf("Invalid input\n");
    return 1;
  }

  // Get user input for elements
  printf("Enter the elements:\n");
  for (int i = 0; i < array_size; i++) {
    scanf("%d", &numbers[i]);
  }

  // Divide the array into approximately equal parts for each thread
  int chunk_size = array_size / NUM_THREADS;
  for (int i = 0; i < NUM_THREADS; i++) {
    data[i].start = i * chunk_size;
    data[i].end = (i + 1) * chunk_size;
    if (i == NUM_THREADS - 1) {
      data[i].end = array_size; // Adjust last thread's end for potential remainder
    }
  }

  // Create threads for sum, max, and min
  pthread_create(&threads[0], NULL, calculate_sum, (void *)&data[0]);
  pthread_create(&threads[1], NULL, calculate_max, (void *)&data[1]);
  pthread_create(&threads[2], NULL, calculate_min, (void *)&data[2]);

  // Wait for all threads to finish
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  // Print the sum using atomic operation for thread safety
  printf("Sum: %d\n", __atomic_load_n(&sum, __ATOMIC_SEQ_CST));
  printf("Max: %d\n", max);
  printf("Min: %d\n", min);

  // Calculate and print the sum of max and min
  int sum_of_max_min = max + min;
  printf("Sum of Max and Min: %d\n", sum_of_max_min);

  return 0;
}

4. write a program on parent child process, where you have to simulate the execution of child before
parent.


#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

void child_process() {
    printf("Child process started\n");
    // Simulate child process execution
    for (int i = 0; i < 5; i++) {
        printf("Child process: %d\n", i);
    }
    printf("Child process finished\n");
}

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        child_process();
    } else {
        printf("Parent process waiting for child...\n");
        waitpid(pid, 0, 0); // Wait for child process to finish
        printf("Parent process finished\n");
    }

    return 0;
}


3.  write a program using system call to read from console until user enters '@' and print the same on a file.



#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

#define MAX_BUFFER_SIZE 1024

int main() {
    int fd_in, fd_out;
    char buffer[MAX_BUFFER_SIZE];
    int bytes_read;

    // Open standard input for reading
    fd_in = STDIN_FILENO;

    // Open the output file for writing (create if it doesn't exist)
    fd_out = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd_out == -1) {
        perror("open");
        return 1;
    }

    while ((bytes_read = read(fd_in, buffer, sizeof(buffer))) > 0) {
        // Check for '@' character
        if (buffer[0] == '@') {
            break;
        }

        // Write the read data to the file
        if (write(fd_out, buffer, bytes_read) == -1) {
            perror("write");
            close(fd_out);
            return 1;
        }
    }

    close(fd_out);

    if (bytes_read == -1) {
        perror("read");
        return 1;
    }

    printf("Input successfully written to output.txt\n");
    return 0;
}



2. write a program using shell script for displaying the list of odd numbers ranging from 21-121.


#!/bin/bash

# Loop through numbers from 21 to 121
for num in {21..121}; do
  # Check if the number is odd using modulo operator (%)
  if [[ $((num % 2)) -ne 0 ]]; then
    echo $num
  fi
done




1.  write a program using directory system calls make a directory on desktop and create a file inside the directory and list the contents of the directory.







